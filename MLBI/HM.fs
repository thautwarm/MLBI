(* almost the vanilla Damas-Hindley-Milner
 type system
 *)
module rec HM

open CamlCompat

(* whether to show the type variable's uniqueness *)
let verbose_printing = ref false

(*
// unique_name
// this is the key point for us
// to avoid checking fresh type
// variables' escapeness
*)

type un
    = { (* to distinguish from variables generated by other runtime *)
        time_ns : int64;
        runtime_id : int;
        name : string
      }

let current_runtime_id_count = ref 0
let current_runtime_time_ns = time_ns()

let un (name: string) =
  { time_ns = current_runtime_time_ns
  ; name = name
  ; runtime_id =
      let i = !current_runtime_id_count in
      let _ = incr current_runtime_id_count in i
  }

let show_un { time_ns = time_ns
            ; runtime_id = runtime_id
            ; name = name
            }
    = if !verbose_printing then
        sprintf "%s@(%u-%u)"  name runtime_id time_ns
      else name

type t =
  (* leaf *)
  | TNom of string
  | TVar of t option ref
  | TBound of un

  | TApp of t * t
  | TArrow of t * t
  | TTup of t list
  | TForall of un list * t

  (* extension from HM *)
  (* for higher rank types, this is not required *)
  (* implicit type is from type class *)
  | TImplicit of t
  with override me.ToString() = HM.show_t me


let top_t =
  let un = un "a" in
  TForall([un], TBound un)

let generic_transform : (t -> t) -> (t -> t)
    = fun self root ->
    (* for ocaml compatibility, we don't use
       active patterns here, though it's a good use case
    *)
    let (!) = self in
    match root with
    | TVar {contents=Some t} -> !t
    | TVar {contents=None} | TBound _ | TNom _ -> root
    | TApp(f, arg) -> TApp(!f, !arg)
    | TArrow(from, to') -> TArrow(!from, !to')
    | TTup(xs) -> TTup <| List.map self xs
    | TForall(ns, t) -> TForall(ns, !t)
    | TImplicit t -> TImplicit (!t)


let generic_trans_ctx : ('ctx -> t -> t) -> ('ctx -> t -> t)
    = fun self ctx root ->
    // for ocaml compatibility, we don't use
    // active patterns here, though it's a good use case
    let (!) = self ctx in
    match root with
    | TVar {contents=Some t} -> !t
    | TVar {contents=None} | TBound _ | TNom _ -> root
    | TApp(f, arg) -> TApp(!f, !arg)
    | TArrow(from, to') -> TArrow(!from, !to')
    | TTup(xs) -> TTup <| List.map (!) xs
    | TForall(ns, t) -> TForall(ns, !t)
    | TImplicit t -> TImplicit (!t)

let generic_check : (t -> bool) -> (t -> bool)
    = fun self root ->
    let (!) = self in
    match root with
    | TVar {contents=Some t} -> !t
    | TVar {contents=None} | TBound _ | TNom _ -> true
    | TApp(f, arg) -> !f && !arg
    | TArrow(from, to') -> !from && !to'
    | TTup(xs) -> List.forall self xs
    | TForall(_, t) -> !t
    | TImplicit t -> !t

let need_parens : t -> bool
    = function
      | TForall(_, _)
      | TApp(_, _)
      | TArrow(_, _) -> true
      | _ -> false



let show_t x =
  let cnt = dict()
  let rec show_t =
    fun x ->
    let nest t =
      let s = show_t t in
      if need_parens t then
        "(" ^ s  ^ ")"
      else s
    in
    let (!) = show_t in
    match x with
    | TVar {contents=Some t} -> show_t t
    | TVar ({contents=None} as ref) ->
      Dict.getForce cnt ref <| fun _ -> sprintf "'%d" (Dict.size cnt)
    | TNom s -> s
    | TBound un -> show_un un
    | TApp(f, a) ->
      !f ^ " " ^ nest a
    | TArrow(a, r) ->
      nest a ^ " -> " ^ !r
    | TTup xs ->
      "<" ^ String.concat ", " (List.map show_t xs) ^ ">"
    | TForall(ns, t)  ->
      "forall " ^ String.concat " " (List.map show_un ns)
      ^ "." ^ !t
    | TImplicit t ->
      "{" ^ !t ^ "}"
  in show_t x